<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>Cover Story - API Access</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><P><FONT SIZE="7"><TT>API Access<BR></TT></FONT><FONT SIZE="5"><TT><B>By Dan Vanderkam</B></TT></FONT></P><P>&#160;&#160;REALbasic has had quite a few improvements and exciting new featuressince the last issue of RBM, but I've found that API Access is probably the biggest.API Access lets you add commands to RB that let your programs do things that weren'tpossible before—and all without a plugin.</P><P>&#160;&#160;However, it's hardly a simple matter to do this. Extremely useful,but not extremely simple—a perfect topic for our last Cover Story!</P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4"><B>Defining the Command</B></FONT></P><P>&#160;&#160;The Macintosh Toolbox is made up of thousands of commands. These commandslet programs do almost everything that they do—access files on the hard drive, drawwindows, or even beep. When you use RB's <TT>beep</TT> command, REALbasic executesthe SysBeep command, which is part of the API. As of 2.0.1, you can directly callthese methods (like SysBeep), and they can greatly improve your program. The firststep is to let REALbasic know that they exist. This is done with a Declare statement.</P><P>&#160;&#160;Any user of Visual Basic will be instantly familiar with the Declarestatement. It works <B>exactly</B> like VB's. For those who have used only RB though,it's a bit bizarre. Here's an example:</P><P><TT>Declare Sub SysBeep Lib &quot;InterfaceLib&quot; (duration as Short)</TT></P><P>&#160;&#160;While this seems to be rather cryptic and illegible, it makes somesense once you know what to look for. </P><P>&#160;&#160;The first part of the line is <TT>Declare Sub</TT>. This lets RB knowthat you're setting up an API call. It could also be <TT>Declare Function</TT>, butwe'll get to that later.</P><P>&#160;&#160;The next part is the name of the API call. In this case, the nameis &quot;SysBeep&quot;, so we just type in SysBeep. This part is quite picky, becauseyou need to type in the <B>exact</B> name–even case matters.</P><P>&#160;&#160;After this comes the library section. The Mac Toolbox is split upinto several libraries. All of these libraries contain commands for doing relatedthings, such as drawing window and controls, speaking, or 3D rendering. The Lib sectionof this command tells RB which library our particular API call is in. For almostall commands, this is InterfaceLib, so <TT>Lib &quot;InterfaceLib&quot;</TT> willwork just fine.</P><P>&#160;&#160;The next part is in parentheses, and should look familiar. Wheneveryou make a new method in RB's code editor, there is a line that says <TT>Sub methodname(parameters) as returnType</TT>. Just as in this line, the section in parenthesesis for parameters. In this particular case, there is one parameter–duration. It'stype may not be familiar, but we'll also get to that later on.</P><P>&#160;&#160;That's what makes up the declare line. RB now knows how to call theSysBeep method, but you might not. So, it's time to learn.</P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4"><B>Using the Command</B></FONT></P><P>&#160;Once you've declared the API call, using it could be as simple as one line,or it could be very complex. It all depends on what the call is, and what types ofparameters it has.</P><P>&#160;&#160;If you create a method in RB, you  can just call it by typing outit's name, followed by a list of parameters. API calls work the same way. So, touse this command, we type out its name (<TT>SysBeep</TT>), and then parameters.</P><P>&#160;&#160;In the case of SysBeep, there's only one parameter: a Short. Shortis basically what the toolbox uses for integers, so we could just use a number like1 for this. In fact, that is what we'll use. Now, we should have this code:</P><P><TT>Declare Sub SysBeep Lib &quot;InterfaceLib&quot; (duration as Short)<BR>SysBeep 1</TT></P><P>&#160;&#160;If you put this code in a button, and then press it, you should heara beep. If you do, keep going. If you didn't, make sure you typed in the code correctly,and are using a fairly new version of RB.</P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4"><B>Other parts</B></FONT></P><P>&#160;This command works, but it will only work on a PowerPC. This may be consideredacceptable by some people, but they're probably also the type of people who believethat everyone uses a G3 running OS 8.6. To add support for 68k Macs, we'll need toadd one more section to the Declare line:<TT> Inline68k</TT>.</P><P>&#160;&#160;This section is definitely the most cryptic of them. It goes rightat the end of the line, which makes the Declare line look like this (the new partis in bold for your enjoyment):</P><P><TT>Declare Sub SysBeep Lib &quot;InterfaceLib&quot; (duration as Short) <B>Inline68K(&quot;A9C8&quot;)</B></TT></P><P>&#160;&#160;Like I said, it's cryptic. As you may have noticed, the four charactersthat we put in there are hexadecimal–base 16. Did we just pull these out of a hat?No, but it might look that way–especially for calls in which this section is 24 digitslong.</P><P><HR SIZE="1" NOSHADE></P><P><IMG SRC="tbfind.gif" WIDTH="250" HEIGHT="160" ALIGN="RIGHT" BORDER="0"><FONTSIZE="4"><B>TBFinder</B></FONT></P><P>&#160;&#160;When accessing the API, there is one program that you absolutely needto have. It's called TBFinder, and is written by Fabian Lidman. It's available at<A HREF="http://home.swipnet.se/~42040/rb.html">http://home.swipnet.se/~42040/rb.html</A>.</P><P>&#160; What does this do that makes it so great? It lets you just type in thename of the call (SysBeep), and it will automatically spew out the cryptic code todeclare it. Sometimes, it'll even give you comments on how to use the call.</P><P>&#160;&#160;Without this, finding and translating an API call is a tedious processthat you need to do with a word proccessor. So why bother? Just use this!</P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4"><B>Finding a Call</B></FONT></P><P>&#160;&#160;TBFinder will convert the API call to RB code, but it can only dothis if you know the call's exact name. And when some calls are as bizarre soundingas <TT>SRPutLanguageObjectIntoHandle</TT>, your odds of guessing one aren't verygood. How do you find them then? You'll need a copy of the Universal Header files.These come with programming applications such as CodeWarrior, which need them todo more than RB does. Because they come with CodeWarrior, they're written in C, themost widely used programming language for macs. This means that the declarationsmight be somewhat hard to find in them. However, if you know what to look for, itwon't be that bad.</P><P>&#160;&#160;First of all, get a copy of the Universal Headers. There's a fairlynew one at the TBFinder site, and it will suit our purposes nicely.</P><P>&#160;&#160;When you have it, open the file &quot;speech.h&quot; in a word proccessor.Now do a search for &quot;extern pascal&quot;. Extern Pascal is just the C versionof Declare Sub. So, every API call will start with it. As in RB, it's followed soonafter by the call's name, and that's what we want.</P><P>&#160;&#160;One of the lines should say &quot;extern pascal OSErr SpeakString&quot;.This is the one we want. This command takes a string, and says it (if PlainTalk isinstalled). So, in order for our program to work, it should actually speak a string.</P><P>&#160;&#160;Now that we have to command, we can type it in TBFinder. It shouldspit out:</P><P><TT>Declare Function SpeakString Lib &quot;InterfaceLib&quot; (s as Ptr) as ShortInline68K(&quot;203C0x0220, 0x000C, 0xA800&quot;)</TT></P><P>&#160;&#160;Among other things, this showcases a bug in TBFinder–the Inline68ksection will give you an error if you leave it like this. Take out teh commas, spaces,and &quot;0x&quot;s from it, and it will be OK. This is what our code should looklike:</P><P><TT>Declare Function SpeakString Lib &quot;SpeechLib&quot; (s as Ptr) as ShortInline68K(&quot;203C0220000CA800&quot;)</TT></P><P>&#160;&#160;This differs in a few ways from the SysBeep command. It has a differenttype of parameter (Ptr), and it returns something. If it returns something (ie, ithas an &quot;As &quot; part after the parentheses) then we need to use Declare Functioninstead of Declare Sub. It also has a significantly longer Inline68k part–16 digits.</P><P>&#160;&#160;We already know how to use a Short, but the Ptr type isn't somethingwe've encountered before. As it turns out, this is the most pesky data type in anAPI call, because it can be just about anything.</P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4"><B>Pointers</B></FONT></P><P>&#160;&#160;When an API call asks for a Ptr, we need to give it a memoryBlockobject. These are created with the <TT>newMemoryBlock</TT> function, and are essentiallya block of data that is a given length. If the API call in C asks for a data typethat RB doesn't understand, then we need to use a Ptr. In this particular case, Theoriginal type (in the Universal Headers) was <TT>StringPtr</TT>. Fortunately, thistype of data is fairly easy to create.</P><P>&#160;&#160;The StringPtr type is a Pascal String (aka PString). These are commonlyused for storing data that isn't a fixed length. The way they work is simple. Thefirst byte is the length of the string, and the rest of the bytes are the actualstring. So for example, if the string were &quot;Hello!&quot;, a PString of thiswould be Chr(7)+&quot;Hello!&quot; (Hello! is 7 characters long). So, to store a7 letter string, we need 8 bytes of space (the length byte and the string).</P><P>&#160;&#160;MemoryBlocks provide a method for creating PStrings, which is calledPString (appropriately enough), so this aspect is easy. Here's the code for puttingthis data into the memoryblock:</P><P><TT>dim m as memoryBlock<BR>m=newMemoryBlock(8)<BR>m.PString(0)=&quot;Hello!&quot;</TT></P><P>&#160;&#160;The first line tells RB that we'll be using a memoryBlock called m.The next line tells it to reserve eight bytes of space for this (this was how muchspace we decided we'd need earlier). The last line tells it to put a PString of &quot;Hello!&quot;into the first position of the memoryBlock–zero.</P><P>&#160;&#160;Now, we can jut pass m where the API call asks for a Ptr.</P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4"><B>Putting it all together</B></FONT></P><P>&#160;&#160;Now that we have something to pass to the SpeakString command, it'sfairly easy from here on out. If you remember our Declare line, it returns a Short.So, we'll also need an integer to store this in. Here's the complete code:</P><P><TT>dim m as memoryBlock, e as integer<BR>Declare Function SpeakString Lib &quot;SpeechLib&quot; (s as Ptr) as Short Inline68K(&quot;203C0220000CA800&quot;)<BR><BR>m=newMemoryBlock(8)<BR>m.Pstring(0)=&quot;Hello!&quot;<BR><BR>e=SpeakString(m)</TT></P><P>&#160;&#160;Now, put this in a button and click it. You should hear your computersay Hello in the default voice. Unlike the beep example, RB doesn't have a SpeakStringcommand. We've just added a useful feature to RB without any plugins!</P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4"><B>Extra Types</B></FONT></P><P>&#160;&#160;There's a way that the last example could have been made a lot easier.The SpeakString command accepts many data types as parameters that RB wouldn't usuallyallow. One of these is PString. So, if we changed the declaration from <TT>(s asPtr)</TT> to <TT>(s as PString)</TT>, we wouldn't have had to do all of the memoryBlockmess. Don't kill me yet though–it was good for you! =)</P><P>&#160;&#160;If we change the type to PString, we can just pass the SpeakStringcommand an ordinary string, not a memoryBlock. So here's what the new code is:</P><P><TT>dim e as integer<BR>Declare Function SpeakString Lib &quot;SpeechLib&quot; (s as PString) as Short Inline68K(&quot;203C0220000CA800&quot;)<BR><BR>e=SpeakString(&quot;Hello!&quot;)</TT></P><P>&#160;&#160;This is a much nicer way of speaking text.</P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4"><B>Wrapping it all up</B></FONT></P><P>&#160;&#160;You can now access the API! The calls that we've used have been fairlysimple, but most API calls are a bit more complicated. Many of them have very strangedata types. Here are how to use some of them:</P><P><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="15%"><B>C Type</B></TD>		<TD WIDTH="85%"><B>What it is, and how to use it</B></TD>	</TR>	<TR>		<TD WIDTH="15%">OSErr</TD>		<TD WIDTH="85%">Basically an integer. Make a one byte memoryBlock, and use the byte(0) property to			set/read its value.</TD>	</TR>	<TR>		<TD WIDTH="15%">Str255</TD>		<TD WIDTH="85%">A type of string. Just use PString for this one. This can only be 255 chars long.</TD>	</TR>	<TR>		<TD WIDTH="15%">Str63</TD>		<TD WIDTH="85%">Another type of string. Use PString for it too. This can only be 63 chars long.</TD>	</TR>	<TR>		<TD WIDTH="15%">GrafPtr</TD>		<TD WIDTH="85%">In the declare line, use WindowPtr. Then, just pass it a window (eg, Window1).</TD>	</TR>	<TR>		<TD WIDTH="15%">WindowPtr</TD>		<TD WIDTH="85%">Same as GrafPtr</TD>	</TR>	<TR>		<TD WIDTH="15%">StringPtr</TD>		<TD WIDTH="85%">We had this in the speech example. Use a PString</TD>	</TR>	<TR>		<TD WIDTH="15%">CStr</TD>		<TD WIDTH="85%">Just like a PString. Use CString instead of PString though.</TD>	</TR>	<TR>		<TD WIDTH="15%">long</TD>		<TD WIDTH="85%">Another type of number. Make a four byte memoryBlock, and use the long(0) property			to set/read it's value.</TD>	</TR>	<TR>		<TD WIDTH="15%">float</TD>		<TD WIDTH="85%">It's the same as RB's single type. Make a four byte memoryBlock, and use the single(0)			property to set/read it.</TD>	</TR>	<TR>		<TD WIDTH="15%">OSType</TD>		<TD WIDTH="85%">A four letter string. Make a four byte memoryBlock, and set each byte (0,1,2,3) to			the ASCII value of each character (ie, TEXT=84, 69, 87, 84)</TD>	</TR>	<TR>		<TD WIDTH="15%">void</TD>		<TD WIDTH="85%">This just means that there are no parameters. Don't pass anything to it.</TD>	</TR>	<TR>		<TD WIDTH="15%" HEIGHT="12">char</TD>		<TD WIDTH="85%" HEIGHT="12">A one byte memoryBlock. Byte(0) is the ASCII value of it.</TD>	</TR></TABLE></BODY></HTML>