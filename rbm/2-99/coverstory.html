<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>Printing with RB</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><P><FONT SIZE="6">Printing with REALbasic</FONT><FONT SIZE="5"><BR>by Alexander Duncan</FONT><BR><BR>&#160;&#160;Printing. It seems simple enough. Just type some text onto the screen,and print it. Standard BASIC code uses this very word: <TT>PRINT &quot;Hello World!&quot;</TT>is everybody’s first BASIC program. A slight variation would be <TT>LPRINT &quot;HelloWorld!&quot;</TT>, which would be used to actually print “Hello World”. The programsends a series of characters to the printer, and the printer prints each charactersequentially, automatically assigning any overflow from the previous line or pageto each subsequent page or line. Right?</P><P>&#160;&#160;Wrong! In this era of laser printers and graphical user interfaces,with multiple fonts and font sizes and multiple paper sizes, printing has becomean increasingly sophisticated and complex <IMG SRC="printref.gif" WIDTH="200" HEIGHT="160"ALIGN="RIGHT" BORDER="1">undertaking in any programming language, and REALbasic hasn’tmade it easy yet either. Although REALbasic does allow the use of a <B>widthWrap</B>method, which automatically calculates where to break each line of text (withoutwhich the text would simply disappear off the right-hand margin of the page), theuse of <B>widthWrap</B> when the printing is longer than a single page means it isimpossible to determine the location in the character data string where the pagewill break. Character data strings are measured in characters, but pages are measuredin pixels. What appears on the screen as pixels is printed as dots per inch. Thus,how does one “map” the “virtual page” of screen text onto the physical printed page?REALbasic formats the virtual page as a screen object, which it prints by sendingit to the printer as a complete graphics object–not a series of characters at all.If this “picture” is larger than the paper size, and <B>widthWrap</B> is turned on,the printer will print the upper left-hand portion of the picture with the dimensionsof the paper size, ignoring the rest of the picture and thus failing to print morethan the first page of a multiple page text document. If <B>widthWrap</B> is turnedoff, the text will simply disappear off the right-hand margin of the page. TeachingREALbasic to print multiple pages of text is difficult, but not impossible. In thisarticle you’ll learn how.</P><P>The major problem in REALbasic printing is determining the position in the characterdata string where the page break occurs. In order to solve this problem we will useour own <B>widthWrap</B>-like method, thus giving the program complete control overthe place where each line breaks. Knowing where each line breaks allows us to countthe total number of lines. Since we can calculate the total number of lines in thegiven font and font size which can be printed using the given paper size, as a functionof the height of the page divided by the height of the font in pixels, and we cancalculate the width of a given string in pixels, and compare it with the width ofthe page, it becomes possible to relate the character data string to the physicalpage in such a way that we can find the point in the character data string at whicheach line and page should break. This procedure can then be repeated indefinitelyuntil all possible pages are printed.</P><P>The program performs its magic using the following 12 REALbasic command wordsprincipally (in order of appearance):</P><P><B>printerSetup</B> class<BR><B>graphics</B> class<BR><B>textFont</B> property of the <B>graphics</B> class<BR><B>textSize</B> property of the <B>graphics</B> class<BR><B>len</B> function <BR><B>mid</B> function<BR><B>stringWidth</B> method of the <B>graphics</B> class<BR><B>width property</B> of the <B>printerSetup</B> class<BR><B>height property</B> of the <B>printerSetup</B> class<BR><B>textHeight</B> property of the <B>graphics</B> class<BR><B>drawString</B> method of the <B>graphics</B> class<BR><B>nextPage</B> method of the<B> graphics</B> class</P><P>The code is divided up into 7 discrete blocks, each of which works much like asubroutine or method:</P><P>Method 1: all properties are declared<BR>Method 2: all properties are initialized<BR>Method 3: each line of text is parsed<BR>Method 4: each line of text is saved in an array<BR>Method 5: all properties are reset for the next line<BR>Method 6: after either a complete page has been saved in method 4, or all the texthas been saved, the page array is printed and cleared<BR>Method 7: all properties are reset for the next page, or the program ends</P><P>Logical flow between these methods is controlled using <B>do</B> loops, <B>if</B>loops, and a single Boolean property. The program also makes important use of the<B>redim</B> method. (The author assumes herein that the reader thoroughly understandsthe use and principles of programming of string arrays as well as general good programmingprinciples.)</P><P><IMG SRC="printsetup.gif" WIDTH="300" HEIGHT="195" ALIGN="RIGHT" ALT="Sample Page Setup dialog"BORDER="1">The program defines 11 properties: printerSetup, which represents theprinter setup object; graphics creates a graphic object corresponding to the virtualpage; checkPointer, which points at each subsequent character in the character datastring; startLine, which indicates the checkPointer position corresponding to thebeginning of each subsequent line; previousSpace, which points at the space beforethe right hand margin in each line; page, a string array which acts as a “container”to hold the contents of each line of the page; lineNumber, which indicates the linebeing parsed and saved; lineOverflow, which contains the string segment in each linewhich is cut off by the right hand margin, from previousSpace to checkPointer; pageNumber,which indicates the page being printed; and eof, a Boolean property which changesfrom false to true when checkPointer reaches the end of the character data string.The following code summarizes methods 1 and 2, above (the complete code example isrepeated at the end of the article):</P><P>[Use a RETURN character to format paragraphs and blank lines. Also make sure youadd a RETURN to the end of the character data string for the following example torun properly.]<BR><BR><TT>Sub Action()//put this code in a pushbutton<BR><BR>dim ps as printerSetup<BR>dim g as graphics<BR>dim checkPointer as integer<BR>dim startLine as integer<BR>dim previousSpace as integer<BR>dim page(0) as string<BR>dim lineNumber as integer<BR>dim lineOverflow as string<BR>dim n as integer<BR>dim pageNumber as integer<BR>dim eof as boolean<BR><BR>ps = new printerSetup //create printer setup object<BR>g = openPrinterDialog(ps) //assign printer setup<BR>//object’s values to a graphics object<BR><BR>if g &lt;&gt; nil then //avoids a NilObjectException error<BR><BR>checkPointer = 1<BR>startLine = 1<BR>previousSpace = 0<BR>lineNumber = 1<BR>lineOverflow = &quot;&quot;<BR>n = 0//use in if loops<BR>pageNumber = 1<BR>eof = false<BR>//the following two lines could easily be adapted<BR>//to read their values from an editfield control<BR>//or a menubar item thus giving the user control <BR>//over which font is used to print the text and size<BR>g.textFont = &quot;Courier&quot; //substitute any font you have<BR>g.textSize = 14//substitute any reasonable size</TT></P><P>&#160;&#160;Method 3 parses each subsequent line. The point of parsing the characterdata string is to locate the spaces immediately before and after the right-hand marginof the page, or determine if the line is shorter than the width of the page. If theline is wider than the page, then the right-hand margin wraps around the previousspace, and the string segment from previousSpace to the space after the margin, indicatedby the checkPointer property, is concatenated to the beginning of the next line.If the line is the same width as the page, then the line wraps on checkPointer. Ifthe line is narrower than the page, shown by the RETURN character, the parse linemethod is exited. If the end of the text has been reached, shown by the length ofthe character data string being equal to the value of checkPointer, then the eofBoolean property is flagged; this indicates the last iteration.<BR><BR><TT>do<BR>do<BR><BR>if checkPointer = len(editField1.text) then<BR>eof = true<BR>end if<BR><BR>do<BR>//ASC returns the ASCII value of the corresponding character<BR>if asc(mid(editField1.text, checkPointer, 1)) = 32 or asc(mid(editField1.text, checkPointer,1)) = 13 then<BR><BR>previousSpace = checkPointer<BR><BR>end if<BR><BR>if eof = false then<BR>checkPointer = checkPointer + 1<BR>end if<BR><BR>loop until (asc(mid(editField1.text, checkPointer, 1)) = 32 and g.stringWidth(mid(editField1.text,startLine, checkPointer - startLine)) &gt;= ps.width) or asc(mid(editField1.text,checkPointer, 1)) = 13</TT><BR><BR><BR>&#160;&#160;Once the line is parsed it is saved to a string array representing thepage, in which each element or cell corresponds to a line of the page. If the linebeing saved is wider than the page, the difference is stored in the lineOverflowproperty and concatenated to the next cell. <BR><BR><TT>if g.stringWidth(mid(editField1.text, startLine, checkPointer - startLine)) &gt;ps.width then<BR><BR>if lineOverflow &lt;&gt; &quot;&quot; then<BR><BR>page.append lineOverflow + mid(editField1.text, startLine, previousSpace - startLine)<BR><BR>lineOverflow = mid(editField1.text, previousSpace + 1, checkPointer - previousSpace+ 1)<BR><BR>else<BR><BR>page.append mid(editField1.text, startLine, previousSpace - startLine)<BR><BR>end if<BR><BR>else<BR><BR>if lineOverflow &lt;&gt; &quot;&quot; then<BR><BR>page.append lineOverflow + mid(editField1.text, startLine, checkPointer - startLine)<BR><BR>lineOverflow = &quot;&quot;<BR><BR>else<BR><BR>page.append mid(editField1.text, startLine, checkPointer - startLine)<BR><BR>end if<BR>end if</TT></P><P><BR>The startLine property, which points to the beginning of the next line, is resetto the previous or subsequent space, depending on whether the line is wider thanthe page, and the line number incremented by 1.<BR><BR><TT>if g.stringWidth(mid(editField1.text, startLine, checkPointer - startLine)) &gt;ps.width then<BR><BR>startLine = previousSpace + 1<BR><BR>else<BR><BR>startLine = checkPointer + 1<BR><BR>end if<BR><BR>lineNumber = lineNumber + 1</TT></P><P>The previous code repeats until the last line of the page or the end of the characterdata string has been reached. After saving the last line, the code exits and proceedsto print. It prints out each cell of the array, line by line, then clears the array.<BR><BR><TT>loop until lineNumber &gt; floor(ps.height / g.textHeight) or eof = true<BR><BR>for n = 1 to ubound(page)<BR>//this use of uBound avoids OutofBoundsException errors<BR>//and is good programming practice generally<BR><BR>g.drawString page(n), 0, g.textHeight * n<BR><BR>next<BR><BR>redim page(0)</TT></P><P>If the end of the character data string has not yet been reached, then the pageand line numbers are incremented by 1. The <B>nextPage</B> command forces the printerto start printing on a new page. The whole process just described repeats, untilthe end of the string is reached and the last page printed.<BR><BR><TT>if eof = false then<BR>pageNumber = pageNumber + 1<BR>lineNumber = 1<BR>g.nextPage<BR>end if<BR>loop until eof = true<BR>end if</TT></P><P>Production of a fully functional and complete printing class would require additionalattention to such issues as adjustable vertical and horizontal margins; the capacityto change fonts and font sizes; indentation and tabs; styled text; right, centre,and full justification; and forced page breaks. However, the code example presentedhere is the core of printing with REALbasic. It accurately determines line length,line breaks, and page breaks for any reasonable font and font size and any numberof pages. Perhaps further articles will address some additional details of<BR><BR><I>Printing with REALbasic<BR>copyright &#169; 1999 by Alexander Duncan (all rights reserved)</I><BR><BR><TT>dim ps as printerSetup<BR>dim g as graphics<BR>dim checkPointer as integer<BR>dim startLine as integer<BR>dim previousSpace as integer<BR>dim page(0) as string<BR>dim lineNumber as integer<BR>dim lineOverflow as string<BR>dim n as integer<BR>dim pageNumber as integer<BR>dim eof as boolean<BR>ps = new printerSetup<BR>g = openPrinterDialog(ps)<BR>if g &lt;&gt; nil then<BR>checkPointer = 1<BR>startLine = 1<BR>previousSpace = 0<BR>lineNumber = 1<BR>lineOverflow = &quot;&quot;<BR>n = 0<BR>pageNumber = 1<BR>eof = false<BR>g.textFont = &quot;Courier&quot;<BR>g.textSize = 14<BR><BR>do<BR>do <BR>if checkPointer = len(editField1.text) then<BR>eof = true<BR>end if<BR>do<BR>if asc(mid(editField1.text, checkPointer, 1)) = 32 or<BR>asc(mid(editField1.text, checkPointer, 1)) = 13 then<BR>previousSpace = checkPointer<BR>end if<BR>if eof = false then<BR>checkPointer = checkPointer + 1<BR>end if<BR>loop until (asc(mid(editField1.text, checkPointer, 1)) = 32 and<BR>g.stringWidth(mid(editField1.text, startLine, checkPointer - startLine))<BR>&gt;= ps.width) or asc(mid(editField1.text, checkPointer, 1)) = 13<BR><BR>if g.stringWidth(mid(editField1.text, startLine, checkPointer -<BR>startLine)) &gt; ps.width then<BR>if lineOverflow &lt;&gt; &quot;&quot; then<BR>page.append lineOverflow + mid(editField1.text, startLine, previousSpace<BR>- startLine)<BR>lineOverflow = mid(editField1.text, previousSpace + 1, checkPointer -<BR>previousSpace + 1)<BR>else<BR>page.append mid(editField1.text, startLine, previousSpace - startLine)<BR>end if<BR>else<BR>if lineOverflow &lt;&gt; &quot;&quot; then<BR>page.append lineOverflow + mid(editField1.text, startLine, (checkPointer<BR>- startLine))<BR>lineOverflow = &quot;&quot;<BR>else<BR>page.append mid(editField1.text, startLine, (checkPointer - startLine))<BR>end if<BR>end if<BR><BR>if g.stringWidth(mid(editField1.text, startLine, checkPointer -<BR>startLine)) &gt; ps.width then<BR>startLine = previousSpace + 1<BR>else<BR>startLine = checkPointer + 1<BR>end if<BR>lineNumber = lineNumber + 1<BR><BR>loop until lineNumber &gt; floor(ps.height / g.textHeight) or eof = true<BR>for n = 1 to ubound(page)<BR>g.drawString page(n), 0, g.textHeight * n<BR>next<BR>redim page(0)<BR><BR>if eof = false then<BR>pageNumber = pageNumber + 1<BR>lineNumber = 1<BR>g.nextPage<BR>end if<BR>loop until eof = true<BR>end if</TT></BODY></HTML>