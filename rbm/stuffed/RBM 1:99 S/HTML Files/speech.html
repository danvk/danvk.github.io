<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>SpeechLib</TITLE></HEAD><BODY TEXT="#000000" BGCOLOR="#FFFFFF"><P><FONT SIZE="6">Speech! </FONT><BR><FONT SIZE="4">A guide to getting your program to stand and deliver.</FONT><BR><FONT SIZE="4">By Chris Murphy</FONT></P><P>&#160;&#160;My best friend challenged me to write a program that could talk. Conqueringthis challenge would send me home with a jackpot valued at $1…plenty of motivationfor this hungry writer.  Ah, but <IMG SRC="speechproj.gif" WIDTH="190" HEIGHT="119"ALIGN="LEFT" BORDER="0" VSPACE="5">where to start? I immediately turned to caf&#233;.realbasic.comon Hotline.  There, I found a helpful project that demonstrates the use of speechin a RealBasic program and colleagues to help explain it.  (Developer Tools/ReusableClasses/Multimedia/speech.p)</P><P>&#160;&#160;At first I thought getting RealBasic to speak text would be difficult.I was wrong, it was only a matter of dragging the speech manager extension from theExtensions Folder into the RealBasic Project Window. A Speech lib icon appeared inthe project window.  Double clicking the Speech lib icon opened a window where Icould enter calls to the library. So I clicked the &quot;New…&quot; button and typedSpeakString as the name, &quot;ptr&quot; as the parameter, and integer as the returntype. You probably know what an integer is, but ptr stands for pointer–a specialtype of variable used in C that <B>points</B> to some data.</P><P>&#160;&#160;Calling SpeakString allows your program to speak up to 255<IMG SRC="newentrypoint.gif"WIDTH="313" HEIGHT="169" ALIGN="RIGHT" BORDER="0"> characters, which amounts to asentence or two. (If you want your program to say more, you will have to call theSpeakText command. Unfortunately, this requires a channel parameter which I was unableto provide through RealBasic. So far, the only solution I know of is to get an RBspeech plugin, or write an AppleScript.)</P><P>&#160;&#160;In the example project that I studied, the author uses an EditFieldand a Pushbutton (see the picture of a window a little bit below this). The textin the EditField is sent to the SpeechLib when the user presses the Pushbutton. Working with Shared Libraries in RealBasic requires you to create memory blocks.This code takes you through the whole process.  A memory block is created one characterlonger than the text in the EditField, and the text is then stored in a Pascal Stringat the beginning of the memory block. Why must the memory block be one byte largerthan the text? That's how a pascal string works–it stores the length (1 byte) first,and <B>then</B> the string.  Errors numbers are stored in the err integer.</P><P><IMG SRC="speechwin.gif" WIDTH="313" HEIGHT="145" ALIGN="BOTTOM" BORDER="0"></P><P>Here's the code for that PushButton:</P><P><IMG SRC="winpushbtn.gif" WIDTH="450" HEIGHT="170" ALIGN="BOTTOM" BORDER="1"></P><P>&#160; SpeakString is just one of many calls you can make to the Speech lib. I got my hands on a copy of the universal header file and looked at some of the othercalls one can make to the Speech lib. You can count and change voices and vary thepitch and rate of the voices. You can start, stop, and pause speech, and much more. It wouldn’t take much to whip up these commands into a plug-in. (I should pointout that a few Hypercard XCMD’s give you access to the Speech lib.)<BR><BR>&#160;&#160;While the challenge proved to be more of a demonstration of RealBasic’spower than an intellectual feat, it exposed that there is still plenty of room forthird party improvement.  Here is the Apple Speech Synthesis header file for plug-inprogrammers and the otherwise curious.<BR><BR><BR><BR><BR>/*<BR> 	File:		SpeechSynthesis.h<BR> <BR> 	Contains:	Speech Interfaces.<BR> <BR> 	Version:	Technology:	System 7.5<BR> 				Release:	Universal Interfaces 3.2<BR> <BR> 	Copyright:	&#169; 1989-1998 by Apple Computer, Inc., all rights reserved.<BR> <BR> 	Bugs?:		For bug reports, consult the following page on<BR> 				the World Wide Web:<BR> <BR> 					http://developer.apple.com/bugreporter/<BR> <BR>*/<BR>#ifndef __SPEECHSYNTHESIS__<BR>#define __SPEECHSYNTHESIS__<BR><BR>#ifndef __MACTYPES__<BR>#include &lt;MacTypes.h&gt;<BR>#endif<BR>#ifndef __MIXEDMODE__<BR>#include &lt;MixedMode.h&gt;<BR>#endif<BR>#ifndef __FILES__<BR>#include &lt;Files.h&gt;<BR>#endif<BR><BR><BR><BR>#if PRAGMA_ONCE<BR>#pragma once<BR>#endif<BR><BR>#ifdef __cplusplus<BR>extern &quot;C&quot; {<BR>#endif<BR><BR>#if PRAGMA_IMPORT<BR>#pragma import on<BR>#endif<BR><BR>#if PRAGMA_STRUCT_ALIGN<BR>	#pragma options align=mac68k<BR>#elif PRAGMA_STRUCT_PACKPUSH<BR>	#pragma pack(push, 2)<BR>#elif PRAGMA_STRUCT_PACK<BR>	#pragma pack(2)<BR>#endif<BR><BR><BR>enum {<BR>	kTextToSpeechSynthType		= FOUR_CHAR_CODE('ttsc'),<BR>	kTextToSpeechVoiceType		= FOUR_CHAR_CODE('ttvd'),<BR>	kTextToSpeechVoiceFileType	= FOUR_CHAR_CODE('ttvf'),<BR>	kTextToSpeechVoiceBundleType = FOUR_CHAR_CODE('ttvb')<BR>};<BR><BR><BR>enum {<BR>	kNoEndingProsody			= 1,<BR>	kNoSpeechInterrupt			= 2,<BR>	kPreflightThenPause			= 4<BR>};<BR><BR><BR>enum {<BR>	kImmediate					= 0,<BR>	kEndOfWord					= 1,<BR>	kEndOfSentence				= 2<BR>};<BR><BR><BR>/*------------------------------------------*/<BR>/* GetSpeechInfo &amp; SetSpeechInfo selectors	*/<BR>/*------------------------------------------*/<BR><BR>enum {<BR>	soStatus					= FOUR_CHAR_CODE('stat'),<BR>	soErrors					= FOUR_CHAR_CODE('erro'),<BR>	soInputMode					= FOUR_CHAR_CODE('inpt'),<BR>	soCharacterMode				= FOUR_CHAR_CODE('char'),<BR>	soNumberMode				= FOUR_CHAR_CODE('nmbr'),<BR>	soRate						= FOUR_CHAR_CODE('rate'),<BR>	soPitchBase					= FOUR_CHAR_CODE('pbas'),<BR>	soPitchMod					= FOUR_CHAR_CODE('pmod'),<BR>	soVolume					= FOUR_CHAR_CODE('volm'),<BR>	soSynthType					= FOUR_CHAR_CODE('vers'),<BR>	soRecentSync				= FOUR_CHAR_CODE('sync'),<BR>	soPhonemeSymbols			= FOUR_CHAR_CODE('phsy'),<BR>	soCurrentVoice				= FOUR_CHAR_CODE('cvox'),<BR>	soCommandDelimiter			= FOUR_CHAR_CODE('dlim'),<BR>	soReset						= FOUR_CHAR_CODE('rset'),<BR>	soCurrentA5					= FOUR_CHAR_CODE('myA5'),<BR>	soRefCon					= FOUR_CHAR_CODE('refc'),<BR>	soTextDoneCallBack			= FOUR_CHAR_CODE('tdcb'),		/* use with SpeechTextDoneProcPtr*/<BR>	soSpeechDoneCallBack		= FOUR_CHAR_CODE('sdcb'),		/* use with SpeechDoneProcPtr*/<BR>	soSyncCallBack				= FOUR_CHAR_CODE('sycb'),		/* use with SpeechSyncProcPtr*/<BR>	soErrorCallBack				= FOUR_CHAR_CODE('ercb'),		/* use with SpeechErrorProcPtr*/<BR>	soPhonemeCallBack			= FOUR_CHAR_CODE('phcb'),		/* use with SpeechPhonemeProcPtr*/<BR>	soWordCallBack				= FOUR_CHAR_CODE('wdcb'),<BR>	soSynthExtension			= FOUR_CHAR_CODE('xtnd'),<BR>	soSoundOutput				= FOUR_CHAR_CODE('sndo')<BR>};<BR><BR><BR>/*------------------------------------------*/<BR>/* Speaking Mode Constants 					*/<BR>/*------------------------------------------*/<BR><BR>enum {<BR>	modeText					= FOUR_CHAR_CODE('TEXT'),		/* input mode constants 					*/<BR>	modePhonemes				= FOUR_CHAR_CODE('PHON'),<BR>	modeNormal					= FOUR_CHAR_CODE('NORM'),		/* character mode and number mode constants*/<BR>	modeLiteral					= FOUR_CHAR_CODE('LTRL')<BR>};<BR><BR><BR><BR>enum {<BR>	soVoiceDescription			= FOUR_CHAR_CODE('info'),<BR>	soVoiceFile					= FOUR_CHAR_CODE('fref')<BR>};<BR><BR><BR>typedef struct OpaqueSpeechChannel* 	SpeechChannel;<BR><BR><BR>struct VoiceSpec {<BR>	OSType 							creator;<BR>	OSType 							id;<BR>};<BR>typedef struct VoiceSpec				VoiceSpec;<BR>typedef VoiceSpec *						VoiceSpecPtr;<BR><BR><BR>enum {<BR>	kNeuter						= 0,<BR>	kMale						= 1,<BR>	kFemale						= 2<BR>};<BR><BR><BR><BR><BR><BR>struct VoiceDescription {<BR>	long 							length;<BR>	VoiceSpec 						voice;<BR>	long 							version;<BR>	Str63 							name;<BR>	Str255 							comment;<BR>	short 							gender;<BR>	short 							age;<BR>	short 							script;<BR>	short 							language;<BR>	short 							region;<BR>	long 							reserved[4];<BR>};<BR>typedef struct VoiceDescription			VoiceDescription;<BR><BR><BR><BR>struct VoiceFileInfo {<BR>	FSSpec 							fileSpec;<BR>	short 							resID;<BR>};<BR>typedef struct VoiceFileInfo			VoiceFileInfo;<BR><BR>struct SpeechStatusInfo {<BR>	Boolean 						outputBusy;<BR>	Boolean 						outputPaused;<BR>	long 							inputBytesLeft;<BR>	short 							phonemeCode;<BR>};<BR>typedef struct SpeechStatusInfo			SpeechStatusInfo;<BR><BR><BR><BR>struct SpeechErrorInfo {<BR>	short 							count;<BR>	OSErr 							oldest;<BR>	long 							oldPos;<BR>	OSErr 							newest;<BR>	long 							newPos;<BR>};<BR>typedef struct SpeechErrorInfo			SpeechErrorInfo;<BR><BR><BR><BR>struct SpeechVersionInfo {<BR>	OSType 							synthType;<BR>	OSType 							synthSubType;<BR>	OSType 							synthManufacturer;<BR>	long 							synthFlags;<BR>	NumVersion 						synthVersion;<BR>};<BR>typedef struct SpeechVersionInfo		SpeechVersionInfo;<BR><BR><BR><BR>struct PhonemeInfo {<BR>	short 							opcode;<BR>	Str15 							phStr;<BR>	Str31 							exampleStr;<BR>	short 							hiliteStart;<BR>	short 							hiliteEnd;<BR>};<BR>typedef struct PhonemeInfo				PhonemeInfo;<BR><BR><BR>struct PhonemeDescriptor {<BR>	short 							phonemeCount;<BR>	PhonemeInfo 					thePhonemes[1];<BR>};<BR>typedef struct PhonemeDescriptor		PhonemeDescriptor;<BR><BR>struct SpeechXtndData {<BR>	OSType 							synthCreator;<BR>	Byte 							synthData[2];<BR>};<BR>typedef struct SpeechXtndData			SpeechXtndData;<BR><BR><BR>struct DelimiterInfo {<BR>	Byte 							startDelimiter[2];<BR>	Byte 							endDelimiter[2];<BR>};<BR>typedef struct DelimiterInfo			DelimiterInfo;<BR><BR>typedef CALLBACK_API( void , SpeechTextDoneProcPtr )(SpeechChannel chan, long refCon,const void **nextBuf, unsigned long *byteLen, long *controlFlags);<BR>typedef CALLBACK_API( void , SpeechDoneProcPtr )(SpeechChannel chan, long refCon);<BR>typedef CALLBACK_API( void , SpeechSyncProcPtr )(SpeechChannel chan, long refCon,OSType syncMessage);<BR>typedef CALLBACK_API( void , SpeechErrorProcPtr )(SpeechChannel chan, long refCon,OSErr theError, long bytePos);<BR>typedef CALLBACK_API( void , SpeechPhonemeProcPtr )(SpeechChannel chan, long refCon,short phonemeOpcode);<BR>typedef CALLBACK_API( void , SpeechWordProcPtr )(SpeechChannel chan, long refCon,unsigned long wordPos, unsigned short wordLen);<BR>typedef STACK_UPP_TYPE(SpeechTextDoneProcPtr) 					SpeechTextDoneUPP;<BR>typedef STACK_UPP_TYPE(SpeechDoneProcPtr) 						SpeechDoneUPP;<BR>typedef STACK_UPP_TYPE(SpeechSyncProcPtr) 						SpeechSyncUPP;<BR>typedef STACK_UPP_TYPE(SpeechErrorProcPtr) 						SpeechErrorUPP;<BR>typedef STACK_UPP_TYPE(SpeechPhonemeProcPtr) 					SpeechPhonemeUPP;<BR>typedef STACK_UPP_TYPE(SpeechWordProcPtr) 						SpeechWordUPP;<BR>enum { uppSpeechTextDoneProcInfo = 0x0000FFC0 }; 				/* pascal no_return_value Func(4_bytes,4_bytes, 4_bytes, 4_bytes, 4_bytes) */<BR>enum { uppSpeechDoneProcInfo = 0x000003C0 }; 					/* pascal no_return_value Func(4_bytes,4_bytes) */<BR>enum { uppSpeechSyncProcInfo = 0x00000FC0 }; 					/* pascal no_return_value Func(4_bytes,4_bytes, 4_bytes) */<BR>enum { uppSpeechErrorProcInfo = 0x00003BC0 }; 					/* pascal no_return_value Func(4_bytes,4_bytes, 2_bytes, 4_bytes) */<BR>enum { uppSpeechPhonemeProcInfo = 0x00000BC0 }; 				/* pascal no_return_value Func(4_bytes,4_bytes, 2_bytes) */<BR>enum { uppSpeechWordProcInfo = 0x00002FC0 }; 					/* pascal no_return_value Func(4_bytes,4_bytes, 4_bytes, 2_bytes) */<BR>#define NewSpeechTextDoneProc(userRoutine) 						(SpeechTextDoneUPP)NewRoutineDescriptor((ProcPtr)(userRoutine),uppSpeechTextDoneProcInfo, GetCurrentArchitecture())<BR>#define NewSpeechDoneProc(userRoutine) 							(SpeechDoneUPP)NewRoutineDescriptor((ProcPtr)(userRoutine),uppSpeechDoneProcInfo, GetCurrentArchitecture())<BR>#define NewSpeechSyncProc(userRoutine) 							(SpeechSyncUPP)NewRoutineDescriptor((ProcPtr)(userRoutine),uppSpeechSyncProcInfo, GetCurrentArchitecture())<BR>#define NewSpeechErrorProc(userRoutine) 						(SpeechErrorUPP)NewRoutineDescriptor((ProcPtr)(userRoutine),uppSpeechErrorProcInfo, GetCurrentArchitecture())<BR>#define NewSpeechPhonemeProc(userRoutine) 						(SpeechPhonemeUPP)NewRoutineDescriptor((ProcPtr)(userRoutine),uppSpeechPhonemeProcInfo, GetCurrentArchitecture())<BR>#define NewSpeechWordProc(userRoutine) 							(SpeechWordUPP)NewRoutineDescriptor((ProcPtr)(userRoutine),uppSpeechWordProcInfo, GetCurrentArchitecture())<BR>#define CallSpeechTextDoneProc(userRoutine, chan, refCon, nextBuf, byteLen, controlFlags) CALL_FIVE_PARAMETER_UPP((userRoutine), uppSpeechTextDoneProcInfo, (chan), (refCon),(nextBuf), (byteLen), (controlFlags))<BR>#define CallSpeechDoneProc(userRoutine, chan, refCon) 			CALL_TWO_PARAMETER_UPP((userRoutine),uppSpeechDoneProcInfo, (chan), (refCon))<BR>#define CallSpeechSyncProc(userRoutine, chan, refCon, syncMessage)  CALL_THREE_PARAMETER_UPP((userRoutine),uppSpeechSyncProcInfo, (chan), (refCon), (syncMessage))<BR>#define CallSpeechErrorProc(userRoutine, chan, refCon, theError, bytePos)  CALL_FOUR_PARAMETER_UPP((userRoutine),uppSpeechErrorProcInfo, (chan), (refCon), (theError), (bytePos))<BR>#define CallSpeechPhonemeProc(userRoutine, chan, refCon, phonemeOpcode)  CALL_THREE_PARAMETER_UPP((userRoutine),uppSpeechPhonemeProcInfo, (chan), (refCon), (phonemeOpcode))<BR>#define CallSpeechWordProc(userRoutine, chan, refCon, wordPos, wordLen)  CALL_FOUR_PARAMETER_UPP((userRoutine),uppSpeechWordProcInfo, (chan), (refCon), (wordPos), (wordLen))<BR>EXTERN_API( NumVersion )<BR>SpeechManagerVersion			(void)														FOURWORDINLINE(0x203C, 0x0000, 0x000C,0xA800);<BR><BR>EXTERN_API( OSErr )<BR>MakeVoiceSpec					(OSType 				creator,<BR>								 OSType 				id,<BR>								 VoiceSpec *			voice)								FOURWORDINLINE(0x203C, 0x0604, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>CountVoices						(short *				numVoices)							FOURWORDINLINE(0x203C, 0x0108, 0x000C,0xA800);<BR><BR>EXTERN_API( OSErr )<BR>GetIndVoice						(short 					index,<BR>								 VoiceSpec *			voice)								FOURWORDINLINE(0x203C, 0x030C, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>GetVoiceDescription				(const VoiceSpec *		voice,<BR>								 VoiceDescription *		info,<BR>								 long 					infoLength)							FOURWORDINLINE(0x203C, 0x0610, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>GetVoiceInfo					(const VoiceSpec *		voice,<BR>								 OSType 				selector,<BR>								 void *					voiceInfo)							FOURWORDINLINE(0x203C, 0x0614, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>NewSpeechChannel				(VoiceSpecPtr 			voice,<BR>								 SpeechChannel *		chan)								FOURWORDINLINE(0x203C, 0x0418, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>DisposeSpeechChannel			(SpeechChannel 			chan)								FOURWORDINLINE(0x203C, 0x021C,0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>SpeakString						(ConstStr255Param 		textToBeSpoken)						FOURWORDINLINE(0x203C,0x0220, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>SpeakText						(SpeechChannel 			chan,<BR>								 const void *			textBuf,<BR>								 unsigned long 			textBytes)							FOURWORDINLINE(0x203C, 0x0624, 0x000C,0xA800);<BR><BR>EXTERN_API( OSErr )<BR>SpeakBuffer						(SpeechChannel 			chan,<BR>								 const void *			textBuf,<BR>								 unsigned long 			textBytes,<BR>								 long 					controlFlags)						FOURWORDINLINE(0x203C, 0x0828, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>StopSpeech						(SpeechChannel 			chan)								FOURWORDINLINE(0x203C, 0x022C, 0x000C,0xA800);<BR><BR>EXTERN_API( OSErr )<BR>StopSpeechAt					(SpeechChannel 			chan,<BR>								 long 					whereToStop)						FOURWORDINLINE(0x203C, 0x0430, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>PauseSpeechAt					(SpeechChannel 			chan,<BR>								 long 					whereToPause)						FOURWORDINLINE(0x203C, 0x0434, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>ContinueSpeech					(SpeechChannel 			chan)								FOURWORDINLINE(0x203C, 0x0238,0x000C, 0xA800);<BR><BR>EXTERN_API( short )<BR>SpeechBusy						(void)														FOURWORDINLINE(0x203C, 0x003C, 0x000C, 0xA800);<BR><BR>EXTERN_API( short )<BR>SpeechBusySystemWide			(void)														FOURWORDINLINE(0x203C, 0x0040, 0x000C,0xA800);<BR><BR>EXTERN_API( OSErr )<BR>SetSpeechRate					(SpeechChannel 			chan,<BR>								 Fixed 					rate)								FOURWORDINLINE(0x203C, 0x0444, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>GetSpeechRate					(SpeechChannel 			chan,<BR>								 Fixed *				rate)								FOURWORDINLINE(0x203C, 0x0448, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>SetSpeechPitch					(SpeechChannel 			chan,<BR>								 Fixed 					pitch)								FOURWORDINLINE(0x203C, 0x044C, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>GetSpeechPitch					(SpeechChannel 			chan,<BR>								 Fixed *				pitch)								FOURWORDINLINE(0x203C, 0x0450, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>SetSpeechInfo					(SpeechChannel 			chan,<BR>								 OSType 				selector,<BR>								 const void *			speechInfo)							FOURWORDINLINE(0x203C, 0x0654, 0x000C,0xA800);<BR><BR>EXTERN_API( OSErr )<BR>GetSpeechInfo					(SpeechChannel 			chan,<BR>								 OSType 				selector,<BR>								 void *					speechInfo)							FOURWORDINLINE(0x203C, 0x0658, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>TextToPhonemes					(SpeechChannel 			chan,<BR>								 const void *			textBuf,<BR>								 unsigned long 			textBytes,<BR>								 Handle 				phonemeBuf,<BR>								 long *					phonemeBytes)						FOURWORDINLINE(0x203C, 0x0A5C, 0x000C, 0xA800);<BR><BR>EXTERN_API( OSErr )<BR>UseDictionary					(SpeechChannel 			chan,<BR>								 Handle 				dictionary)							FOURWORDINLINE(0x203C, 0x0460, 0x000C, 0xA800);<BR><BR><BR><BR><BR>#if PRAGMA_STRUCT_ALIGN<BR>	#pragma options align=reset<BR>#elif PRAGMA_STRUCT_PACKPUSH<BR>	#pragma pack(pop)<BR>#elif PRAGMA_STRUCT_PACK<BR>	#pragma pack()<BR>#endif<BR><BR>#ifdef PRAGMA_IMPORT_OFF<BR>#pragma import off<BR>#elif PRAGMA_IMPORT<BR>#pragma import reset<BR>#endif<BR><BR>#ifdef __cplusplus<BR>}<BR>#endif<BR><BR>#endif /* __SPEECHSYNTHESIS__ */</BODY></HTML>