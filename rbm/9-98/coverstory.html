<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>untitled</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><P><FONT SIZE="7"><B>Sockets</B></FONT><BR><FONT SIZE="5">Cover Story</FONT></P><P><FONT SIZE="5">&#160;&#160;</FONT><FONT SIZE="4">For most people, nothing canbe more confusing than the TCP/IP socket control (making it great for a cover story!).</FONT></P><P>&#160;&#160;&#160;However, this control is something that makes RB almost as goodas any other programming language for internet apps.</P><P><HR SIZE="1" NOSHADE></P><P><IMG SRC="modemjunk.gif" WIDTH="191" HEIGHT="156" ALIGN="RIGHT" BORDER="0">&#160;&#160;&#160;Beforethe Internet, the only way to connect to the outside world using a modem was to talkdirectly to the modem. This was a confusing and complex mess. For an idea of allthe settings you had to have, just look at a serial control. I doubt you ever wantedto know what XON, CTS and DTR were, not to mention Stop bits and Parity. Though therewas a lot you could do with a modem, there were still a few things that were impossible,like being connected to two places at once.</P><P>&#160;&#160;&#160;The internet changed all that. Now, you could have multipleconnections open at the same time. And as an extra bonus, you didn't have to fiddlewith all those cryptic settings!</P><P>&#160;&#160;&#160;Simply transmitting data is pointless though. You have to sendit in some type of format. A system for sending requests, and getting files froma server is called a protocol. There are doezens of protocols, and you can make oneof your own if you want. All you'll need to do is create a server application, anda client application.</P><P>&#160;&#160;But enough of making your <B>own</B> protocol. Here's a list of allthe major protocols, and what subclass you can use to access them:</P><P><TABLE BORDER="0">	<TR>		<TD><B>Protocal</B></TD>		<TD><B>Class</B></TD>		<TD><B>Price</B></TD>		<TD><B>Author</B></TD>	</TR>	<TR>		<TD COLSPAN="4"><HR SIZE="1" NOSHADE>		</TD>	</TR>	<TR>		<TD><B>HTTP</B>-Hypertext Transfer protocol</TD>		<TD>httpSocket 1.3</TD>		<TD>free</TD>		<TD>Dan Vanderkam</TD>	</TR>	<TR>		<TD><B>FTP</B>-File Transfer protocol</TD>		<TD>RB FTP</TD>		<TD>free</TD>		<TD>Brian F. Jones</TD>	</TR>	<TR>		<TD><B>Hotline</B>-Hotline Protocol</TD>		<TD>HotlineSocketLite<BR>			HotShell*<BR>			HotSocket *</TD>		<TD>free<BR>			free<BR>			$30</TD>		<TD>Jason Toffaletti &amp; Spht<BR>			Kevin Pfohr &amp; Nick<BR>			James Milne</TD>	</TR>	<TR>		<TD><B>POP3</B>-Post Office Protocol</TD>		<TD>POP3 Class</TD>		<TD>free</TD>		<TD>Bjorn Einhugur</TD>	</TR>	<TR>		<TD><B>SMTP</B>-I have no idea.</TD>		<TD>xSMTP</TD>		<TD>free</TD>		<TD>Brian F. Jones</TD>	</TR>	<TR>		<TD><B>Finger</B>-Finger protocol</TD>		<TD>CrossFinger</TD>		<TD>free</TD>		<TD>Brian F. Jones***</TD>	</TR>	<TR>		<TD><B>Telnet</B></TD>		<TD>&lt;none&gt;</TD>		<TD>--</TD>		<TD>--</TD>	</TR>	<TR>		<TD><B>AOL</B>-America Off (oops!) Online**</TD>		<TD>&lt;none&gt;</TD>		<TD>--</TD>		<TD>--</TD>	</TR></TABLE><FONT SIZE="5"><BR></FONT><FONT SIZE="2">*-These haven't been released yet<BR>**-Yes, AOL <B>is</B> a protocol.<BR>***-Yes, Brian Jones is the god of RB Sockets.</FONT></P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="6">Making your own protocol</FONT><BR><BR>&#160;&#160;The first step in making your own protocol is laying it out, decidingwhat it will do, and how it will do it. Let's make our protocol a simple chat protocol.Here's how it will work:</P><BLOCKQUOTE>	<P>• Everything that is sent is sent in the following format: <BR>		<TABLE BORDER="0">	<TR>		<TD><TT>NORM</TT></TD>		<TD><B><TT>Hello Everyone!</TT></B></TD>		<TD><TT>}~\</TT></TD>	</TR>	<TR>		<TD>A four letter code that tells<BR>			the server what type of info<BR>			is contained in the next field.</TD>		<TD>The actual content. This<BR>			would appear in the chat<BR>			window.</TD>		<TD>A terminator that tells<BR>			the server that the info<BR>			is done.</TD>	</TR>	</TABLE></P>	<P>• There are three codes:<BR>	&#160;&#160;<TT>NORM</TT> - A normal chat item<BR>	&#160;&#160;<TT>OPTN</TT> - A special chat item (like an opt-chat in Hotline)</P>	<P>• There can only be two people on the server (this is for simplicity).</BLOCKQUOTE><P>&#160;&#160;Confused? It's not that bad. Here are some examples of what is sentand what happens:</P><P><TABLE BORDER="0">	<TR>		<TD><B>What is sent</B></TD>		<TD><B>What happens</B></TD>	</TR>	<TR>		<TD><TT>NORMHello everyone}~\</TT></TD>		<TD><TT>Someone: Hello Everyone</TT> appears in everyone's chat window.</TD>	</TR>	<TR>		<TD><TT>OPTNis insane}~\</TT></TD>		<TD><TT>&#160;*** Someone is insane</TT> appears in everyone's chat window.</TD>	</TR></TABLE></P><P>&#160;&#160;&#160;Hopefully that made it a tad more clear. All that the clientapplications will ever recieve is text that ends with <TT>}~\</TT>. They simply putthat in the chat window.</P><P><FONT SIZE="5">Making the server</FONT></P><P>&#160;&#160;The server application is the most important part of a protocol. Itwill do most of the work, and has to be in near-constant communication with multiplepeople.</P><P>&#160;&#160;Sockets can either listen or connect. If a socket is listening, thenit waits for other sockets to connect to it (using their cleverly named <TT>Connect</TT>method). If they're not listening, then they can connect to any other server thatIS listening.</P><P>&#160;&#160;For a server naturally, all the sockets should be listening. Thatway, when a client connects, they can respond correctly.</P><P>&#160;&#160;So, in the server project, create a socket (make sure its port propertyis set to 4222) and and two editfields. Then create a pushbutton next to the secondeditfield. In the window's open event, put this code: <TT>Socket1.Listen</TT>. Thisforces the socket to wait until a user connects to it. Also, create a property inthe window called <TT>&quot;p as string&quot;</TT> The window should look somethinglike this:</P><BLOCKQUOTE>	<P><IMG SRC="serverwin.gif" WIDTH="309" HEIGHT="249" ALIGN="BOTTOM" BORDER="0"></P></BLOCKQUOTE><P>&#160;&#160;Now open the code editor for the socket. In the DataAvailable event,put in the code you see below:</P><P><IMG SRC="code.gif" WIDTH="411" HEIGHT="232" ALIGN="BOTTOM" BORDER="1"></P><P>&#160;&#160;This code runs whenever the client has sent data. For example, whenthey type a line of chat, this routine handles it. It takes whatever they sent, andsends it back in the correct format. Then, it adds it to the server's chat window.</P><P>&#160;&#160;Now we want the server to be able to send some chat text of theirown! So, in the pushbutton's action event, put this:</P><P><IMG SRC="code2.gif" WIDTH="389" HEIGHT="196" ALIGN="BOTTOM" BORDER="1"></P><P>&#160;&#160;This allows the person running the server to participate in the chatas well. The last two lines of each of these pieces of code add the text to the editfield. Why didn't I just use &quot;<TT>EditField1.Text=EditField1.Text+res&quot;</TT>?Because that makes the field flicker like crazy (see <A HREF="..\8-98\index.html">lastmonth's</A> tips).</P><P>&#160;&#160;Believe it or not, that's all there is to the server! That wasn'thard at all! Now for the client, which isn't even <B>that</B> complicated...</P><P><FONT SIZE="5">The Client</FONT></P><P><FONT SIZE="2">&#160;&#160;</FONT>The client is the part of the program that doesthe connecting. So, for a start, make a window that looks like this:</P><BLOCKQUOTE>	<P><IMG SRC="clientwin.gif" WIDTH="309" HEIGHT="312" ALIGN="BOTTOM" BORDER="0"></P></BLOCKQUOTE><P>&#160;&#160;The client program is fairly simple. Also make a &quot;<TT>p as string</TT>&quot;property in it, just like you did in the server project.</P><P>&#160;&#160;In the Connect button's action event...</P><P><IMG SRC="code3.gif" WIDTH="373" HEIGHT="113" ALIGN="BOTTOM" BORDER="1"></P><P>&#160;&#160;This tells the socket what server to connect to, what port to use,and then connects.</P><P>&#160;&#160;In the DataAvailable event of the socket...</P><P><IMG SRC="code4.gif" WIDTH="421" HEIGHT="169" ALIGN="BOTTOM" BORDER="1"></P><P>&#160;&#160;This routine is similiar to the server's, but it doesn't send backany text. It just takes whatever it gets, checks to see if that's all there is, andthen adds it to the chat field.</P><P>&#160;&#160;In the Send button's action event...</P><P><IMG SRC="code5.gif" WIDTH="384" HEIGHT="144" ALIGN="BOTTOM" BORDER="1"></P><P>&#160;&#160;This routine is simple enough. It checks whether they held down optionas they sent the chat. It then sends the chat text and info to the server in thecorrect format.</P><P>&#160;&#160;And you're done!</P><P>&#160;&#160;Compile both projects, and run the server. Then open up the client,and type in &quot;127.0.0.1&quot; in the IP field. 127.0.0.1 is a shortcut that basicallymeans &quot;my IP address&quot;. Then click connect, and chat away!</P><P>&#160;&#160;If you want to connect to another person, then type their IP insteadof 127.0.0.1. You can find your own IP in the Info box of your PPP program (i.e.OT/PPP, FreePPP, MacPPP, etc.)</P><P><FONT SIZE="5">More Stuff</FONT></P><P>&#160;&#160;As you probably realize, this client/server demonstration is hardlyvery powerful, but it could easily be improved. Here are some tips that you mightwant to try yourself:</P><UL>	<LI>Support for multiple users on at once. Just use a different socket &amp; port	for each.	<LI>Support for user lists	<LI>Names	<LI>Messages	<LI>Administrative messages	<LI>Disconnecting	<LI>Anything else you might want to do.</UL><P>&#160;&#160;This tutorial should give you the groundwork for making your own protocols,and client &amp; server apps. Who knows, you might just make the next Hotline...</BODY></HTML>