<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>Cover Story</TITLE></HEAD><BODY TEXT="#000000" BGCOLOR="#FFFFFF"><P><FONT SIZE="6"><TT><B>Cover Story - DR2 features</B></TT></FONT><FONT SIZE="5"><TT><B><BR>By Dan Vanderkam, editor on the run</B></TT></FONT></P><P><FONT SIZE="5">&#160;&#160;</FONT><FONT SIZE="4">It seems like it's brand new,but believe it or not, there have been almost as many DR2 releases now as there wereDR1s. Shocked? So am I.</FONT></P><P><FONT SIZE="4">&#160;&#160;While not nearly as many major features have been addedin the DR2s, there HAVE been a lot, and they've all been horribly underdocumented.So, in this article, I'll try to explain the top five new features besides databasesthat I haven't explained yet: Variant data types, the new listbox, the new SpriteSurface, the RGBSurface object, and class constructors. So open up a copy of DR2,and hop on for the ride!</FONT></P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4">&#160;&#160;</FONT><FONT SIZE="5">Feature 1: Variant data types</FONT></P><P><FONT SIZE="4">&#160;&#160;&#160;The only major new feature in DR2r30 besidesdatabase improvements was the Variant data type. As I mentioned in the </FONT><AHREF="news.html"><FONT SIZE="4">news</FONT></A><FONT SIZE="4"> section, it allowsyou to store anything in one variable type. If v is a variant, <TT>v=&quot;Hi&quot;</TT>and v=3.3 will both work. Here's a lengthier example:</FONT></P><P><TT>&#160;&#160;Dim V1 as Variant<BR>&#160;&#160;Dim s as string, i as integer<BR>&#160;&#160;V1=&quot;Hi&quot;<BR>&#160;&#160;s=V1<BR>&#160;&#160;msgbox s<BR>v=20<BR>i=v<BR>msgbox str(i)</TT><FONT SIZE="4"></FONT></P><P><FONT SIZE="4">&#160;&#160;&#160;This seems simple enough, but there's more!</FONT></P><P><FONT SIZE="4">&#160;&#160;&#160;Using the VarType function, you can find outwhat type of data the variant contains. For example, if v contains an integer, then<TT>VarType(v)</TT> would return 2—the code for an integer. Other codes include 5for a double, 8 for a string, 11 for a boolean, and 13 for an object.</FONT></P><P><FONT SIZE="4">&#160;&#160;&#160;But there's <B>still</B> more! You can use thenew collection class to create a collection of variants. To use it, you use its Addmethod. This takes two parameters: a variant, and a string to identify it. Here'san example:</FONT></P><P>&#160;&#160;<TT>Dim C as collection<BR>&#160;&#160;dim v, v2, v3 as Variant<BR>v=&quot;William Thomas Riker&quot;<BR>v2=3.333<BR>v3=true<BR>c.Add v, &quot;#1&quot;<BR>c.Add v2, &quot;#2&quot;<BR>c.Add v3, &quot;#3&quot;<BR><BR></TT>&#160;&#160;<FONT SIZE="4">Now, if we want to access these items, we use theItem methods. You can either supply a string (the one you specified when you usedAdd), or an integer (just like a normal array). Here's a continuation of the codewe just used:</FONT></P><P><TT>&#160;&#160;Dim s as string, i as single, b as boolean<BR>&#160;&#160;s=c.Item(&quot;#1&quot;)<BR>&#160;&#160;i=c.Item(1)<BR>b=c.Item(&quot;#3&quot;)</TT></P><P><FONT SIZE="4">&#160;&#160;As you may have guessed, that stores all the collectionitems in variables that are of the correct type. A collection is a essentially aspecial array that can contain anything.</FONT></P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4">&#160;</FONT><FONT SIZE="5">&#160;Feature 2: The New Listbox</FONT></P><P><FONT SIZE="4">&#160;&#160;&#160;One of the neat things about DR2 versions isthe ability to put checkboxes in a cell (like the Extensions Manager). However, DR2can also let the user EDIT cells in a listbox (like the Finder). There are some niftynew tools to do this, and I'll explain them all!</FONT></P><P><FONT SIZE="4">&#160;&#160;<B>Method 1: ColumnType</B></FONT></P><P><FONT SIZE="4">&#160;&#160;Typically, if you're going to put a checkbox or editablecell in a listbox, you'll put one in each cell in an entire column. That's what thenew listbox's ColumnType() property does. If you want to make the first column haveCheckboxes, you could use the statement <TT>Listbox1.ColumnType(0)=2</TT>. Changethe 2 to a 3 to make it an editable cell. 1 or 0 is for a normal column, but it defaultsto this.</FONT></P><P><FONT SIZE="4">&#160;&#160;<B>Method 2: CellType</B></FONT></P><P><FONT SIZE="4">&#160;&#160;Sometimes, there ARE exceptions. For example, you mightnot want a certain cell to be editable, even if the rest of the column was. That'swhere the CellType property comes in.</FONT></P><P><FONT SIZE="4">&#160;&#160;By default, every cell in a column is the column'sdefault type. However, if you use the CellType method (its parameters are the rowand then column), you can set styles on an individual basis. The same values areused for this as the ColumnType property.</FONT></P><P><FONT SIZE="4">&#160;&#160;So, to wrap it up, if you put this code in, it wouldmake every cell in column #1 have a checkbox, and every cell in column #2 (exceptfor row #3) be editable:</FONT></P><P><TT>&#160;&#160;ListBox1.ColumnType(0)=2<BR>&#160;&#160;ListBox1.ColumnType(1)=3<BR>&#160;&#160;ListBox1.CellType(1, 2)=1</TT></P><P><FONT SIZE="4">&#160;&#160;<B>Using it</B></FONT></P><P><FONT SIZE="4"><B>&#160;&#160;</B>All of these great new features do us no goodif we can't manipulate them! One new property, and one new event help us here.</FONT></P><P><FONT SIZE="4">&#160;&#160;First of all, whenever a checkbox in a list is clicked,or text in a cell is edited by the user, the CellAction(row, column) event is fired.The Row and Column parameters tell you which cell was changed.</FONT></P><P><FONT SIZE="4">&#160;&#160;Secondly, the CellCheck(row,column) boolean propertylets you find out whether or not a cell is checked, and set whether or not it's checked.</FONT></P><P><FONT SIZE="4">&#160;&#160;Also, you can use the Cell(row, column) property tofind out a cell's text. This has been around for a while, and is covered in the onlinereference.</FONT></P><P><FONT SIZE="4">&#160;&#160;Here's some code to show you how it works:</FONT></P><P><TT>&#160;&#160;Sub CellAction(row as integer, column as integer)<BR>&#160;&#160;&#160;&#160;If ListBox1.ColumnType(column)=2 then<BR>&#160;&#160;&#160;&#160;&#160;&#160;If ListBox1.CellCheck(row, column) then<BR>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Msgbox &quot;It's checked&quot;<BR>&#160;&#160;&#160;&#160;&#160;&#160;Else<BR>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MsgBox &quot;It's NOT checked. Nooooo!&quot;<BR>&#160;&#160;&#160;&#160;&#160;&#160;End if<BR>&#160;&#160;&#160;&#160;Elseif Listbox1.ColumnType(column)=3 then<BR>&#160;&#160;&#160;&#160;&#160;&#160;Msgbox ListBox1.Cell(row, column)<BR>&#160;&#160;&#160;&#160;End If<BR>&#160;&#160;End Sub</TT></P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4"><TT>&#160;&#160;</TT></FONT><FONT SIZE="5">Feature 3: The New SpriteSurface</FONT></P><P><FONT SIZE="4">&#160;&#160;The SpriteSurface (which was the cover in the </FONT><AHREF="http://www.nd.edu/~jvanderk/rbm/8-98/"><FONT SIZE="4">August Issue</FONT></A><FONTSIZE="4">) is essential for making games in RB. However, in DR2r19, the first runat a brand new sprite engine was introduced. It was the same as the old one (whichwas added in DR1r34 by the way), but offered two improvements: the PaintTile event,and the Scroll method. As is usual, I'll explain these...</FONT></P><P><FONT SIZE="4">&#160;&#160;The idea behind the new Sprite engine is that you canmake a background using tiles. This allows you to make patterns for a background(which you see in almost every side-scrolling game), and scroll the background easily.First off, there's the PaintTile event. Here's how to use it.</FONT></P><P><FONT SIZE="4">&#160;&#160;PaintTile has three parameters. One is a graphics objectthat lets you draw in the 64x64 tile. The second and third refer to the positionof the tile, so you can decide what to draw in it. In this example, we'll make asky and a ground that scroll.</FONT></P><P><FONT SIZE="4">&#160;&#160;First off, we'll want to put this in the PaintTileevent:</FONT></P><P><TT>&#160;&#160;Sub PaintTile(g As Graphics, xpos as integer, ypos as integer)<BR>&#160;&#160;&#160;&#160;if ypos&lt;5 then<BR>&#160;&#160;&#160;&#160;&#160;&#160;if xpos=5 then<BR>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;g.ForeColor=rgb(255,255,255)<BR>&#160;&#160;&#160;&#160;&#160;&#160;else<BR>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;g.ForeColor=rgb(128, 128, 255)<BR>&#160;&#160;&#160;&#160;&#160;&#160;end if<BR>&#160;&#160;&#160;&#160;else<BR>&#160;&#160;&#160;&#160;&#160;&#160;g.ForeColor=rgb(128, 255, 128)<BR>&#160;&#160;&#160;&#160;end if<BR>&#160;&#160;&#160;&#160;g.FillRect 0, 0, 64, 64<BR>&#160;&#160;End Sub</TT></P><P><FONT SIZE="4">&#160;As you can see, that code fills the tile with a nice shadeof blue if the tile's Y position is less than 5. If it's greater than 5, the routineassumes it's the ground, and fills it with a nice shade of green. It also makes asingle white cell, so you can see it scroll horizontally too.</FONT></P><P><FONT SIZE="4">&#160;&#160;Now, let's see the true usefulness of tiles—their abilityto scroll.</FONT></P><P><FONT SIZE="4">&#160;&#160;In the SpriteSurface's NextFrame event, put this code:</FONT></P><P><TT>Sub NextFrame<BR>&#160;&#160;dim dx, dy as integer<BR>&#160;&#160;if me.KeyDown(126) then // 126=Up Arrow<BR>&#160;&#160;&#160;&#160;dy=-10<BR>&#160;&#160;elseif me.KeyDown(125) then // 125=Down Arrow<BR>&#160;&#160;&#160;&#160;dy=10<BR>&#160;&#160;end if<BR><BR>&#160;&#160;if me.KeyDown(123) then // 123=Left Arrow<BR>&#160;&#160;&#160;&#160;dx=-10<BR>&#160;&#160;elseif me.KeyDown(124) then // 124=Right Arrow<BR>&#160;&#160;&#160;&#160;dx=10<BR>&#160;&#160;end if<BR><BR>&#160;&#160;if dx&lt;&gt;0 or dy&lt;&gt;0 then<BR>&#160;&#160;&#160;&#160;me.Scroll dx, dy<BR>&#160;&#160;end if<BR>End Sub</TT></P><P><FONT SIZE="4">&#160;&#160;Now that was rather long! If that code confused you,all it does is to check which arrow keys are down, and (if neccesary) scroll thecanvas using the Scroll method. Its parameters, dx and dy, are integers that determinehow far to scroll in each direction.</FONT></P><P><FONT SIZE="4">&#160;&#160;It is slow, but it's a neat feature, and will be improvedupon in the future (at least I hope it will).</FONT></P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="5">&#160;&#160;Feature 4: RGBSurface</FONT></P><P><FONT SIZE="4">&#160;&#160;The RGBSurface object was added in DR2r2, making itone of the first DR2 features. The RGBSurface is very similiar to the Graphics object,except you can only use it with 32 bit pictures created using NewPicture, and theonly way to get info from it or draw to it is through the pixel method.</FONT></P><P><FONT SIZE="4">&#160;&#160;Now why would you ever want to use something with suchlarge limitations? Simply put: Speed.</FONT></P><P><FONT SIZE="4">&#160;&#160;To get an RGBSurface object, you use this code (orsomething similiar to it):</FONT></P><P><TT>Dim P as Picture<BR>Dim R as RGBSurface<BR>P=NewPicture(64,64,32)<BR>R=P.RGBSurface</TT></P><P><FONT SIZE="4">&#160;&#160;We now have an RGB surface! The NewPicture commandmade a 64x64, 32-bit picture, and we got an RGBSurface using its cleverly named &quot;RGBSurface&quot;property. Now, let's draw to it.</FONT></P><P><TT>R.Pixel(1,1)=rgb(10,10,10)<BR>r.Pixel(2,2)=rgb(20,20,20)</TT></P><P><FONT SIZE="4">&#160;&#160;This could keep on going and going, but for the sakeof space, we won't. Also, you can still use the graphics object for a picture thatyou've used an RGBSurface with. RGBSurfaces are just added speed boosts.</FONT></P><P><FONT SIZE="4">&#160;&#160;Just how much faster is it? I ran some speed testswith it against the graphics object using the following code:</FONT></P><P><TT>dim G as Graphics<BR>Dim P as Picture<BR>Dim R as RGBSurface<BR>dim i, j as integer<BR>dim s1, s2 as single<BR>P=NewPicture(256,256,32)<BR>R=P.RGBSurface<BR>G=P.Graphics<BR><BR>s1=ticks<BR>for i=1 to 256<BR>for j=1 to 256<BR>r.Pixel(i,j)=rgb(200,200,200)<BR>next<BR>next<BR>s1=ticks-s1<BR><BR>s2=ticks<BR>for i=1 to 256<BR>for j=1 to 256<BR>g.Pixel(i,j)=rgb(200,200,200)<BR>next<BR>next<BR>s2=ticks-s2</TT></P><P><FONT SIZE="4">&#160;&#160;I set a breakpoint after the last line, and checkedout s1 and s2 in the Variables window. The result? The RGBSurface won. It took atotal of 6 ticks. The Graphics object took a whopping total of 161.</FONT></P><P><FONT SIZE="4">&#160;&#160;Just for the sake of the example, I tried this witha 512x512 picture too. The RGBSurface won this 31 to 684. It filled 262,144 pixelsin just over half a second!</FONT></P><P><FONT SIZE="4">&#160;&#160;So, if you have a program that uses the graphics object's.Pixel method a lot, use an RGBSurface—it's 2000 to 2600 percent faster. Now THAT'Sone heck of a speed jump!</FONT></P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="5">&#160;&#160;Feature 5: Class Constructors</FONT></P><P><FONT SIZE="4">&#160;&#160;Have you ever made a class that required some sortof Initialize method? Something that had values that needed to be set whenever itwas created? If it was a control subclass, you could use its Open event. If it wasn't,you had to create a method that was always called after you used the New statementto make the class.</FONT></P><P><FONT SIZE="4">&#160;&#160;If you've had this problem, and have DR2r14 or later,then constructors are perfect for you!</FONT></P><P><FONT SIZE="4">&#160;&#160;Essentially, you can make any method in a class firewhen it's instantiated. Just give it the same name as the class.</FONT></P><P><FONT SIZE="4">&#160;&#160;For example, make a class called &quot;Class1&quot;.Next, make a property called &quot;id as integer&quot;. Then, make a new method called&quot;class1&quot; with one property: &quot;i as integer&quot;. For its code, put&quot;id=i&quot;. It should now look like this:</FONT></P><P><IMG SRC="contructor.gif" WIDTH="410" HEIGHT="159" ALIGN="BOTTOM" BORDER="1"></P><P><FONT SIZE="4">&#160;&#160;You've made a constructor! To see it in action, putthis code in a pushbutton, and click it:</FONT></P><P><IMG SRC="constructtest.gif" WIDTH="379" HEIGHT="137" ALIGN="BOTTOM" BORDER="1"></P><P><FONT SIZE="4">&#160;&#160;As you can see, the Class1 method is fired wheneveryou click the button. And, as the message box confirms, id IS set.</FONT></P><P><FONT SIZE="4">&#160;&#160;You can also have contructor routines return data,and take any number of parameters. And best of all, thanks to method overloading(see </FONT><A HREF="tips.html"><FONT SIZE="4">tips</FONT></A><FONT SIZE="4">, thisissue) you can make multiple constructors for different situations!</FONT></P><P><HR SIZE="1" NOSHADE></P><P><FONT SIZE="4">&#160;&#160;Well, that was fun! If anything, this article shouldhave shown you that, even if the changes in DR2 aren't as visible, they're stillvery, very useful.</FONT></BODY></HTML>